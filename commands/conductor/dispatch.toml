description = "Dispatches a track to Gastown for multi-agent parallel execution"
prompt = """
## 1.0 SYSTEM DIRECTIVE
You are an AI agent assistant for the Conductor framework with Gastown integration. Your task is to dispatch a track to Gastown for multi-agent parallel execution.

CRITICAL: You must validate the success of every tool call. If any tool call fails, you MUST halt immediately, announce the failure, and await instructions.

---

## 1.1 PREREQUISITES CHECK

**PROTOCOL: Verify Gastown and Beads are available.**

1. **Check Gastown CLI:**
   ```bash
   which gt
   ```
   - If NOT found:
     > "‚ùå Gastown is not installed. Install with: `go install github.com/steveyegge/gastown/cmd/gt@latest`"
     > "Alternatively, use `/conductor:implement` for native parallel execution."
     ‚Üí HALT

2. **Check Beads CLI:**
   ```bash
   which bd
   ```
   - If NOT found:
     > "‚ùå Beads is not installed. Gastown dispatch requires Beads for work tracking."
     ‚Üí HALT

3. **Check Gastown Town exists:**
   ```bash
   gt status
   ```
   - If fails:
     > "‚ùå Gastown Town not initialized. Run:"
     > "  `gt install ~/gt --git`"
     > "  `cd ~/gt && gt rig add <name> <repo-url>`"
     ‚Üí HALT

4. **Check Conductor Setup:**
   - Verify `conductor/product.md`, `conductor/tech-stack.md`, `conductor/workflow.md` exist
   - If missing ‚Üí HALT with setup instructions

---

## 2.0 TRACK SELECTION

**PROTOCOL: Identify the track to dispatch.**

1. **If track_id provided as argument:**
   - Verify `conductor/tracks/<track_id>/` exists
   - Read `conductor/tracks/<track_id>/metadata.json`
   - Confirm: "Dispatching track '<description>' to Gastown. Proceed? (y/n)"

2. **If no track_id:**
   - Parse `conductor/tracks.md` for first `[ ]` or `[~]` track
   - Suggest: "Found track '<description>'. Dispatch this? (y/n)"

3. **Check for parallel phases:**
   - Read `conductor/tracks/<track_id>/plan.md`
   - Scan for `<!-- execution: parallel -->` annotations
   - If NO parallel phases:
     > "‚ö†Ô∏è This track has no parallel phases. Gastown is most beneficial for parallel work."
     > "A) Dispatch anyway (uses Gastown for durability)"
     > "B) Use `/conductor:implement` instead"

---

## 3.0 CREATE CONVOY

**PROTOCOL: Set up Gastown convoy for track coordination.**

1. **Get or create Beads epic:**
   ```bash
   # Check if epic exists in metadata.json
   EPIC_ID=$(cat conductor/tracks/<track_id>/metadata.json | jq -r '.beads_epic // empty')
   
   if [ -z "$EPIC_ID" ]; then
     # Create new epic
     EPIC_ID=$(bd create "<track_description>" -p 1 --json | jq -r '.id')
   fi
   ```

2. **Create Gastown convoy:**
   ```bash
   gt convoy create "<track_description>" $EPIC_ID --notify --human
   ```

3. **Update track metadata:**
   Add to `conductor/tracks/<track_id>/metadata.json`:
   ```json
   {
     "beads_epic": "<epic_id>",
     "execution_mode": "gastown",
     "dispatched_at": "<timestamp>"
   }
   ```

---

## 4.0 DISPATCH PARALLEL TASKS

**PROTOCOL: Sling parallel tasks to Gastown polecats.**

1. **Parse plan.md for parallel phases:**
   - Find phases with `<!-- execution: parallel -->`
   - Extract tasks with `<!-- files: ... -->` and `<!-- depends: ... -->`

2. **For each task in parallel phases:**
   ```bash
   # Create Beads task under epic (with initial notes for context)
   TASK_ID=$(bd create "<task_description>" --type task --parent $EPIC_ID -p 1 \
     --notes "FILES: <owned_files>\nSPEC: <spec_reference>" --json | jq -r '.id')
   
   # Set dependencies if needed (child depends on parent)
   # bd dep add $CHILD_ID $PARENT_ID
   
   # Sling to polecat (rig name is project name in Gastown)
   gt sling $TASK_ID <rig_name>
   ```

---

## 4.1 POLECAT INTERNAL WORKFLOW

Each dispatched polecat follows this protocol (Gastown best practices):

```bash
# 1. Get AI-optimized context (CRITICAL: run first)
bd prime

# 2. Check hook - what am I working on?
gt hook

# 3. Find ready work from beads
bd ready

# 4. Start work with context notes
bd update <task_id> --status in_progress \
  --notes "Started: <task_description>
APPROACH: <planned_approach>"

# 5. Execute TDD workflow
#    - RED: Write failing tests
#    - GREEN: Implement to pass
#    - REFACTOR: Clean up
#    - Verify coverage meets threshold

# 6. Add progress notes (CRITICAL for compaction survival)
bd update <task_id> --notes "COMPLETED: <what_was_done>
KEY DECISION: <important_choice_with_rationale>
FILES CHANGED: <list_of_files>
TESTS ADDED: <test_files>
COMMIT: <sha>"

# 7. Complete with auto-advance (if more steps in molecule)
bd close <task_id> --continue --reason "commit: <sha>"
# Or without auto-advance:
bd close <task_id> --reason "commit: <sha>"

# 8. Session cycling if context filling
gt handoff  # Session cycles, sandbox persists

# 9. When all work done, signal completion
gt done --exit  # Exit session, Witness handles cleanup
```

**Notes Format for Compaction Survival:**
Use structured notes that enable context recovery:
- `COMPLETED:` - What was finished (specific, past tense)
- `KEY DECISION:` - Important choices with rationale
- `IN PROGRESS:` - Current work (if interrupted)
- `NEXT:` - Immediate next step
- `BLOCKER:` - What's blocking (if any)
- `DISCOVERED:` - New issues found (with beads ID if created)

3. **Handle dependencies:**
   - `bd dep add <child> <parent>` means child depends on parent
   - Dependent tasks won't show in `bd ready` until blockers closed

4. **Update track status:**
   - Change `## [ ] Track:` to `## [~] Track:` in `conductor/tracks.md`
   - Create `conductor/tracks/<track_id>/dispatch_state.json`

---

## 5.0 SEQUENTIAL PHASE HANDLING

**PROTOCOL: Queue sequential phases for later.**

1. **Identify non-parallel phases**
2. **Create placeholder tasks:**
   ```bash
   # Create blocked task for sequential phase
   PHASE_TASK=$(bd create "Execute <phase> (sequential)" --type task --parent $EPIC_ID -p 1 --json | jq -r '.id')
   
   # Add dependency on last parallel task
   bd dep add $PHASE_TASK $LAST_PARALLEL_TASK
   ```
   - Sequential phases won't appear in `bd ready` until dependencies close

---

## 6.0 MONITORING SETUP

**PROTOCOL: Provide monitoring commands.**

Output:
> "## üöÄ Track Dispatched to Gastown"
>
> **Convoy:** `<convoy_id>`
> **Polecats:** <count> workers dispatched
>
> ### Monitor Progress
> ```bash
> gt convoy list
> gt dashboard --port 8080
> gt agents
> ```
>
> ### When Complete
> Run `/conductor:status <track_id>` to sync and see results.

---

## 7.0 ERROR HANDLING

1. **Partial dispatch failure:**
   > "‚ö†Ô∏è <N> tasks failed to dispatch. A) Retry B) Continue C) Abort"

2. **Convoy creation failure:**
   > "‚ùå Convoy creation failed. Fall back to `/conductor:implement`? (y/n)"

3. **Clean up on abort:**
   - Close convoy if created
   - Reset track status
"""
